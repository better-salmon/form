---
description: Zustand with mutative middleware patterns
globs: lib/create-form-hook.tsx
alwaysApply: false
---

# Zustand Mutative Patterns

When using zustand with the mutative middleware, follow these patterns for clean, type-safe state management.

## Import Pattern

```typescript
import { create } from "zustand";
import { mutative } from "zustand-mutative";
```

## Type Definition Pattern

Always separate State and Actions for better organization:

```typescript
type State = {
  // Define your state properties
  count: number;
  items: string[];
  user: User | null;
};

type Actions = {
  // Define your action methods
  increment: (qty: number) => void;
  addItem: (item: string) => void;
  setUser: (user: User) => void;
  reset: () => void;
};
```

## Store Creation Pattern

Use the double function call pattern with mutative middleware and return pattern for complex stores:

```typescript
export const useStore = create<State & Actions>()(
  mutative((set, get) => {
    // ======================================================================
    // TYPED HELPER FUNCTIONS (For Complex Stores)
    // ======================================================================

    /** Gets typed state properties */
    const getItems = () => get().items;
    const getUser = () => get().user;

    /** Mutates state with type safety */
    const mutateItems = (mutator: (items: string[]) => void) => {
      set((state) => {
        mutator(state.items);
      });
    };

    const mutateUser = (mutator: (user: User | null) => void) => {
      set((state) => {
        mutator(state.user);
      });
    };

    return {
      // ====================================================================
      // INITIAL STATE
      // ====================================================================
      count: 0,
      items: [],
      user: null,

      // ====================================================================
      // ACTIONS
      // ====================================================================

      /** Increments count by specified quantity */
      increment: (qty) => {
        set((state) => {
          state.count += qty;
        });
      },

      /** Adds item to the list */
      addItem: (item) => {
        mutateItems((items) => {
          items.push(item);
        });
      },

      /** Updates user data */
      setUser: (user) => {
        set((state) => {
          state.user = user;
        });
      },

      /** Resets all state to initial values */
      reset: () => {
        set((state) => {
          state.count = 0;
          state.items = [];
          state.user = null;
        });
      },
    };
  }),
);
```

## Simple Store Pattern (Without Helpers)

For simple stores, use the direct pattern:

```typescript
export const useSimpleStore = create<State & Actions>()(
  mutative((set, get) => ({
    // Initial state
    count: 0,
    items: [],
    user: null,

    // Actions - use direct mutation inside set()
    increment: (qty: number) => {
      set((state) => {
        state.count += qty;
      });
    },

    addItem: (item: string) => {
      set((state) => {
        state.items.push(item);
      });
    },

    setUser: (user: User) => {
      set((state) => {
        state.user = user;
      });
    },

    reset: () => {
      set((state) => {
        state.count = 0;
        state.items = [];
        state.user = null;
      });
    },
  })),
);
```

## Best Practices

1. **Direct Mutation**: Inside `set()`, mutate state directly. Don't return new objects.
2. **Type Safety**: Always type your store as `State & Actions`
3. **Naming**: Use descriptive action names that indicate what they do
4. **Organization**: Group related state and actions together
5. **Complex Updates**: For complex nested updates, mutative makes it much cleaner than manual immutable updates
6. **Helper Functions**: For complex stores, create typed helper functions to eliminate repetitive type casting
7. **Documentation**: Add JSDoc comments for actions explaining their purpose
8. **Section Organization**: Use clear section headers with comments for better code organization
9. **Arrow Function Formatting**: Use braces for arrow functions that don't return values to avoid confusing void expressions

## Typed Helper Functions Pattern

For complex stores with many type assertions, create helper functions:

```typescript
// Typed getters
const getTypedProperty = () => get().property as TypedProperty<T>;

// Typed mutators
const mutateTypedProperty = (mutator: (property: TypedProperty<T>) => void) => {
  set((state) => {
    mutator(state.property as TypedProperty<T>);
  });
};

// Specific state setters
const setPropertyState = (field: keyof T, newState: SomeState) => {
  mutateTypedProperty((property) => {
    property[field].state = newState;
  });
};
```

## Array and Object Mutations

```typescript
// Arrays
set((state) => {
  state.items.push(newItem);
  state.items.splice(index, 1);
  state.items[index] = updatedItem;
});

// Nested objects
set((state) => {
  state.user.name = newName;
  state.user.settings.theme = "dark";
});

// Using mutation helpers for complex operations
mutateItems((items) => {
  items.push(newItem);
  items.sort((a, b) => a.priority - b.priority);
});
```

## When to Use Helper Functions

Use typed helper functions when you have:

- Multiple type assertions throughout your store
- Complex nested state structures
- Repetitive mutation patterns
- Large stores with many actions

For simple stores with basic state, stick to the direct pattern without helpers.
